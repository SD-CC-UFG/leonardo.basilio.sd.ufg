// Code generated by protoc-gen-go. DO NOT EDIT.
// source: MessagingServer.proto

package grpc

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChatMessage_ChatMessageType int32

const (
	ChatMessage_TEXT ChatMessage_ChatMessageType = 0
)

var ChatMessage_ChatMessageType_name = map[int32]string{
	0: "TEXT",
}

var ChatMessage_ChatMessageType_value = map[string]int32{
	"TEXT": 0,
}

func (x ChatMessage_ChatMessageType) String() string {
	return proto.EnumName(ChatMessage_ChatMessageType_name, int32(x))
}

func (ChatMessage_ChatMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08173c4f010cdc7, []int{1, 0}
}

type TextMessage struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}
func (*TextMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08173c4f010cdc7, []int{0}
}

func (m *TextMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TextMessage.Unmarshal(m, b)
}
func (m *TextMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TextMessage.Marshal(b, m, deterministic)
}
func (m *TextMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextMessage.Merge(m, src)
}
func (m *TextMessage) XXX_Size() int {
	return xxx_messageInfo_TextMessage.Size(m)
}
func (m *TextMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TextMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TextMessage proto.InternalMessageInfo

func (m *TextMessage) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type ChatMessage struct {
	Type                 ChatMessage_ChatMessageType `protobuf:"varint,1,opt,name=type,proto3,enum=Chat.Grpc.ChatMessage_ChatMessageType" json:"type,omitempty"`
	UserCredential       *UserCredential             `protobuf:"bytes,2,opt,name=user_credential,json=userCredential,proto3" json:"user_credential,omitempty"`
	DateTime             uint32                      `protobuf:"varint,3,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	Text                 *TextMessage                `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ChatMessage) Reset()         { *m = ChatMessage{} }
func (m *ChatMessage) String() string { return proto.CompactTextString(m) }
func (*ChatMessage) ProtoMessage()    {}
func (*ChatMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08173c4f010cdc7, []int{1}
}

func (m *ChatMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChatMessage.Unmarshal(m, b)
}
func (m *ChatMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChatMessage.Marshal(b, m, deterministic)
}
func (m *ChatMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatMessage.Merge(m, src)
}
func (m *ChatMessage) XXX_Size() int {
	return xxx_messageInfo_ChatMessage.Size(m)
}
func (m *ChatMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChatMessage proto.InternalMessageInfo

func (m *ChatMessage) GetType() ChatMessage_ChatMessageType {
	if m != nil {
		return m.Type
	}
	return ChatMessage_TEXT
}

func (m *ChatMessage) GetUserCredential() *UserCredential {
	if m != nil {
		return m.UserCredential
	}
	return nil
}

func (m *ChatMessage) GetDateTime() uint32 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *ChatMessage) GetText() *TextMessage {
	if m != nil {
		return m.Text
	}
	return nil
}

func init() {
	proto.RegisterEnum("Chat.Grpc.ChatMessage_ChatMessageType", ChatMessage_ChatMessageType_name, ChatMessage_ChatMessageType_value)
	proto.RegisterType((*TextMessage)(nil), "Chat.Grpc.TextMessage")
	proto.RegisterType((*ChatMessage)(nil), "Chat.Grpc.ChatMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MessagingServerClient is the client API for MessagingServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MessagingServerClient interface {
	TalkAndListen(ctx context.Context, opts ...grpc.CallOption) (MessagingServer_TalkAndListenClient, error)
}

type messagingServerClient struct {
	cc *grpc.ClientConn
}

func NewMessagingServerClient(cc *grpc.ClientConn) MessagingServerClient {
	return &messagingServerClient{cc}
}

func (c *messagingServerClient) TalkAndListen(ctx context.Context, opts ...grpc.CallOption) (MessagingServer_TalkAndListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MessagingServer_serviceDesc.Streams[0], "/Chat.Grpc.MessagingServer/TalkAndListen", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagingServerTalkAndListenClient{stream}
	return x, nil
}

type MessagingServer_TalkAndListenClient interface {
	Send(*ChatMessage) error
	Recv() (*ChatMessage, error)
	grpc.ClientStream
}

type messagingServerTalkAndListenClient struct {
	grpc.ClientStream
}

func (x *messagingServerTalkAndListenClient) Send(m *ChatMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *messagingServerTalkAndListenClient) Recv() (*ChatMessage, error) {
	m := new(ChatMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MessagingServerServer is the server API for MessagingServer service.
type MessagingServerServer interface {
	TalkAndListen(MessagingServer_TalkAndListenServer) error
}

func RegisterMessagingServerServer(s *grpc.Server, srv MessagingServerServer) {
	s.RegisterService(&_MessagingServer_serviceDesc, srv)
}

func _MessagingServer_TalkAndListen_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MessagingServerServer).TalkAndListen(&messagingServerTalkAndListenServer{stream})
}

type MessagingServer_TalkAndListenServer interface {
	Send(*ChatMessage) error
	Recv() (*ChatMessage, error)
	grpc.ServerStream
}

type messagingServerTalkAndListenServer struct {
	grpc.ServerStream
}

func (x *messagingServerTalkAndListenServer) Send(m *ChatMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *messagingServerTalkAndListenServer) Recv() (*ChatMessage, error) {
	m := new(ChatMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MessagingServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Chat.Grpc.MessagingServer",
	HandlerType: (*MessagingServerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TalkAndListen",
			Handler:       _MessagingServer_TalkAndListen_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "MessagingServer.proto",
}

func init() { proto.RegisterFile("MessagingServer.proto", fileDescriptor_e08173c4f010cdc7) }

var fileDescriptor_e08173c4f010cdc7 = []byte{
	// 276 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xc1, 0x4e, 0xc2, 0x40,
	0x10, 0x86, 0x59, 0x6d, 0x08, 0x9d, 0x06, 0x4a, 0x36, 0x91, 0x54, 0xb8, 0xd4, 0x1e, 0x4c, 0xe3,
	0xa1, 0x31, 0xf5, 0xe6, 0x0d, 0x08, 0xf1, 0xa2, 0x97, 0xba, 0x26, 0xc4, 0x0b, 0xa9, 0xed, 0xa4,
	0x34, 0x42, 0x69, 0x76, 0xa7, 0x06, 0x9e, 0xdb, 0x17, 0x30, 0xac, 0x48, 0x56, 0xa2, 0xb7, 0xd9,
	0xd9, 0x7f, 0xbe, 0xec, 0xb7, 0x03, 0x17, 0x4f, 0xa8, 0x54, 0x5a, 0x94, 0x55, 0xf1, 0x8c, 0xf2,
	0x03, 0x65, 0x54, 0xcb, 0x0d, 0x6d, 0xb8, 0x3d, 0x5d, 0xa6, 0x14, 0x3d, 0xc8, 0x3a, 0x1b, 0xf6,
	0xc7, 0x0d, 0x2d, 0xcd, 0xcb, 0xe0, 0x0a, 0x1c, 0x81, 0x5b, 0xfa, 0x9e, 0x44, 0xce, 0xc1, 0x22,
	0xdc, 0x92, 0xc7, 0x7c, 0x16, 0xda, 0x89, 0xae, 0x83, 0x4f, 0x06, 0xce, 0x1e, 0xf1, 0x93, 0xb9,
	0x07, 0x8b, 0x76, 0x35, 0xea, 0x4c, 0x2f, 0xbe, 0x8e, 0x8e, 0xf8, 0xc8, 0x48, 0x99, 0xb5, 0xd8,
	0xd5, 0x98, 0xe8, 0x19, 0x3e, 0x01, 0xb7, 0x51, 0x28, 0x17, 0x99, 0xc4, 0x1c, 0x2b, 0x2a, 0xd3,
	0x95, 0x77, 0xe6, 0xb3, 0xd0, 0x89, 0x2f, 0x0d, 0xcc, 0x8b, 0x42, 0x39, 0x3d, 0x06, 0x92, 0x5e,
	0xf3, 0xeb, 0xcc, 0x47, 0x60, 0xe7, 0x29, 0xe1, 0x82, 0xca, 0x35, 0x7a, 0xe7, 0x3e, 0x0b, 0xbb,
	0x49, 0x67, 0xdf, 0x10, 0xe5, 0x1a, 0xf9, 0xcd, 0x41, 0xc0, 0xd2, 0xd4, 0x81, 0x41, 0x35, 0x34,
	0x0f, 0x62, 0x23, 0x70, 0x4f, 0x5e, 0xc9, 0x3b, 0x60, 0x89, 0xd9, 0x5c, 0xf4, 0x5b, 0xf1, 0x1c,
	0xdc, 0x93, 0xef, 0xe4, 0x33, 0xe8, 0x8a, 0x74, 0xf5, 0x3e, 0xae, 0xf2, 0xc7, 0x52, 0x11, 0x56,
	0x7c, 0xf0, 0xb7, 0xfb, 0xf0, 0x9f, 0x7e, 0xd0, 0x0a, 0xd9, 0x2d, 0x9b, 0xb4, 0x5f, 0xad, 0x42,
	0xd6, 0xd9, 0x5b, 0x5b, 0x6f, 0xe0, 0xee, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x60, 0xa2, 0x40, 0xe2,
	0xb7, 0x01, 0x00, 0x00,
}
